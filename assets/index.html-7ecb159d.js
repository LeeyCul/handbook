import{_ as n,r as o,o as r,c as t,a as e,b as d,d as i,e as s}from"./app-4b62f06d.js";const c={},l=s(`<h2 id="_1、问题" tabindex="-1"><a class="header-anchor" href="#_1、问题" aria-hidden="true">#</a> 1、问题</h2><p>前端通过打开新的标签页进行跳转，打开的页面过多会导致浏览器奔溃，特别是含有地图的页面，对浏览器内存占用过多，本次在开发就出现，我跳转到子系统，关闭子系统结果浏览器直接崩溃。</p><h2 id="_2、原因" tabindex="-1"><a class="header-anchor" href="#_2、原因" aria-hidden="true">#</a> 2、原因</h2><p>谷歌浏览器在给新开窗口分配进程时，看是否同源，非同源页面会单独分配一个新进程，而同源页面只会分配一个相同的新进程。在上述场景中，A，B 页面同源，所以谷歌浏览器只会分配一个进程，这就导致 B 页面在请求未结束时就关闭，A 页面会卡死。</p><h2 id="_3、解决办法" tabindex="-1"><a class="header-anchor" href="#_3、解决办法" aria-hidden="true">#</a> 3、解决办法</h2><p>只要在 window.open 第三个参数上加一个 noopener 就可以了，这样 chrome 在分配进程的时候，就会单独分配一个新的进程，就不会造成父页面卡死了。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>window.open(url, &quot;_blank&quot;, &quot;noopener&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_4、注意" tabindex="-1"><a class="header-anchor" href="#_4、注意" aria-hidden="true">#</a> 4、注意</h2><p>noopener 会导致新打开的页面无法使用 window.opener 访问到父页面。如果需要访问的话就不能这么干了。我们现在两个页面之间没有交互，就直接用 noopener 解决了。当然如果存在需要解决这种问题，建议保存 A 页面的 sessionStorage 到 localStorage，进入 B 页面获取 localStorage 中本页面所需要的值，然后根据需要决定是否删除 localStorage 中的值即可.</p>`,9),h={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open",target:"_blank",rel:"noopener noreferrer"};function p(_,u){const a=o("ExternalLinkIcon");return r(),t("div",null,[l,e("p",null,[e("a",h,[d("window.open API 参数详情"),i(a)])])])}const m=n(c,[["render",p],["__file","index.html.vue"]]);export{m as default};
